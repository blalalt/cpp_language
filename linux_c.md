## 0.1 一个Linux程序的诞生

```c++
// hello_world.c
#include <stdio.h>

int main() {
    printf("Hello World.");
    return 0;
}
```

通过GCC编译，就得到了一个应用程序。

当然，整个过程看似简单，其实是GCC工具集帮我们完成了许多步骤。具体的步骤包括：

* 预处理

  * 头文件包含：该头文件的所有代码会在#include处展开

  * 宏替换：展开宏定义(注：模板是在编译期生成代码)

  * 去掉注释：

  * 条件编译：不符合的会被删除，进不到编译阶段

    ```shell
    # 查看 预处理的结果
    gcc -E hello_world.c -o hello_world.i
    # 常见错误
    1. 为什么在头文件中不能定义变量？
    这是因为定义全局变量的代码会存在于所有以\#include包含该头文件的文件中，也就是说所有的这些文件，都会定义一个同样的全局变量，这样就不可避免地造成了冲突。
    ```

    

* 编译

  * 检查语法(语法分析)

  * 生成汇编

    ```shell
    # 查看编译结果
    gcc -S hello_world.i -o hello_world.s
    ```

    

* 汇编

  * 将源代码翻译成可执行的指令，并生成目标文件

    ```shell
    # 查看汇编结果
    gcc -C hello_world.s -o hello_world.o
    ```

    

* 链接

  * 将各个目标文件-包括库文件链接成一个可执行程序。在这个过程中涉及**地址和空间的分配**、**符号解析**、**重定位**等。
  * 工具：GNU的链接器ld

* ...

我们可以使用以下命令，查看完整的编译过程

```shell
gcc -g -Wall -v hello_world.c -o hello_world
```



## 0.2 程序的构成 

在Linux下，可执行程序的格式为ELF格式，我们可以使用`readelf`查看程序的ELF格式。

```shell
readelf hello_world
```

ELF文件的主要内容是由各个section和symbol表组成。

常见的段(section)包括：

* text段：代码段，用于保存可执行指令
* data段：数据段，用于保存有非0初始值的全局变量和静态变量
* bss段：用于保存没有初始值或初值为0的全局变量和静态变量，当程序加载时，bss段中的变量会被初始化为0。这个段并不占用物理空间
* debug段：用于保存调试信息，不使用-g选项，则不会生成
* dynamic段：用于保存动态链接信息
* rodata段：用于保存只读数据，如const修饰的常量、字符串变量等
* symbol段：用于保存符号表，使用strip可以去掉符号信息
* init段：用于保存进程启动时的执行程序。当进程启动时，系统会自动执行这部分代码。
* fini段：用于保存进程退出时的执行程序。当进程结束时，系统会自动执行这部分代码。

## 0.3 程序是如何跑起来的

在Linux系统下，我们可以使用`strace`跟踪系统调用，从而帮助自己研究和理解系统程序的加载、运行和退出的过程。

```shell
strace ./hello_world
```

在Linux环境下，该命令的过程：

* 由shell调用`fork`，在子进程中执行命令
* 调用`execve`加载hello_world，然后ld会分别检查ld.so.nohwcap和ld.so.preload。其中，如果ld.so.nohwcap存在，则ld会加载其中未优化版本的库。如果ld.so.preload存在，则ld会加载其中的库——在一些项目中，我们需要拦截或替换系统调用或C库，此时就会利用这个机制，使用LD_PRELOAD来实现。
* 利用mmap将ld.so.cache映射到内存中，ld.so.cache中保存了库的路径，这样就完成了所有的准备工作。
* 接着ld加载c库——libc.so.6，利用mmap及mprotect设置程序的各个内存区域，到这里，程序运行的环境已经完成。
* write会向文件描述符1（即标准输出）输出"Hello world！\n"，返回值为13，它表示write成功的字符个数。
* 最后调用exit_group退出程序，此时参数为0，表示程序退出的状态——此例中hello-world程序返回0

## 0.4 系统调用

系统调用是操作系统提供的服务，是应用程序和内核通信的接口。相对于普通函数，系统调用的消耗是巨大的。用户空间的程序默认是通过栈来传递参数的。对于系统调用来说，**内核态和用户态使用的是不同的栈**，这使得**系统调用的参数只能通过寄存器的方式进行传递**。

## 0.5 线程安全

线程安全即程序在多线程环境下能够“安全”的执行，也即符合正确的逻辑结果。

为了实现线程安全，要么只能使用局部变量或资源，要么利用锁等同步机制，实现全局变量或资源的串行访问。

## 0.6 原子性

以前原子被认为是物理组成的最小单元，所以在计算机领域，就借其不可分割的这层含义作为隐喻。对于计算机科学来说，如果变量是原子的，那么对这个变量的任何访问和更改都是原子的。如果操作是原子的，那么这个操作将是不可分割的，要么成功，要么失败，不会有任何的中间状态。

## 0.7 可重入函数

从字面上理解，可重入就是可重复进入。在编程领域，它不仅仅意味着可以重复进入，还要求在进入后能成功执行。这里的重复进入，是指当前进程已经处于该函数中，这时程序会允许当前进程的某个执行流程再次进入该函数，而不会引发问题。这里的执行流程不仅仅包括多线程，还包括信号处理、longjump等执行流程。所以，可重入函数一定是线程安全的，而线程安全函数则不一定是可重入函数。从以上定义来看，很难说出哪些函数是可重入函数，但是可以很明显看出哪些函数是不可以重入的函数。当函数使用锁的时候，尤其是互斥锁的时候，该函数是不可重入的，否则会造成死锁。若函数使用了静态变量，并且其工作依赖于这个静态变量时，该函数也是不可重入的，否则会造成该函数工作不正常。

## 0.8 阻塞和同步

这里的阻塞与非阻塞，都是指I/O操作。在Linux环境下，所有的I/O系统调用默认都是阻塞的。那么何谓阻塞呢？阻塞的系统调用是指，当进行系统调用时，除非出错（被信号打断也视为出错），进程将会一直陷入内核态直到调用完成。非阻塞的系统调用是指无论I/O操作成功与否，调用都会立刻返回。

这里的同步与非同步，也是指I/O操作。当把阻塞、非阻塞、同步和非同步放在一起时，不免会让人眼花缭乱。同步是否就是阻塞，非同步是否就是非阻塞呢？实际上在I/O操作中，它们是不同的概念。同步既可以是阻塞的，也可以是非阻塞的，而常用的Linux的I/O调用实际上都是同步的。这里的同步和非同步，是指I/O数据的复制工作是否同步执行。以系统调用read为例。阻塞的read会一直陷入内核态直到read返回；而非阻塞的read在数据未准备好的情况下，会直接返回错误，而当有数据时，非阻塞的read同样会一直陷入内核态，直到read完成。这个read就是同步的操作，即I/O的完成是在当前执行流程下同步完成的。如果是非同步即异步，则I/O操作不是随系统调用同步完成的。调用返回后，I/O操作并没有完成，而是由操作系统或者某个线程负责真正的I/O操作，等完成后通知原来的线程。

## 1.1.1 文件、文件描述符和文件表

Linux内核**将一切都视为文件**，在Linux中，文件既可以是传统上的物理文件，也可以是设备、管道甚至一块内存。这些文件**利用VFS机制，以文件系统的形式挂载在Linux内核中**，**对外提供一致的接口**。

从数值上看，**文件描述符是一个非负整数，其本质就是一个句柄**，所以也可以认为文件描述符就是一个文件句柄。那么何为句柄呢？一切对于用户透明的返回值，即可视为句柄。**用户空间利用文件描述符与内核进行交互；而内核拿到文件描述符后，可以通过它得到用于管理文件的真正的数据结构**。使用文件描述符即句柄，有两个好处：一是增加了安全性，句柄类型对用户完全透明，用户无法通过任何hacking的方式，更改句柄对应的内部结果，比如Linux内核的文件描述符，只有内核才能通过该值得到对应的文件结构；二是增加了可扩展性，用户的代码只依赖于句柄的值，这样实际结构的类型就可以随时发生变化，与句柄的映射关系也可以随时改变，这些变化都不会影响任何现有的用户代码。

**Linux的每个进程都会维护一个文件表，以便维护该进程打开文件的信息，包括打开的文件个数、每个打开文件的偏移量等信息**。

**文件表的实现**

内核中进程对应的结构是file_struct，进程中的文件表保存在file_struct->files中，其代码结构如下：

![image-20200103091747365](/home/liutao/linux_imgs/image-20200103091747365.png)

![image-20200103091851905](/home/liutao/linux_imgs/image-20200103091851905.png)

下面看看files_struct是如何使用默认的fdtab和fd_array的，init是Linux的第一个进程，它的文件表是一个全局变量，代码如下：

![image-20200103092340429](/home/liutao/linux_imgs/image-20200103092340429.png)

因此，初始状态下，files_struct、fdtable和files的关系如图1-1所示。

![image-20200103092425650](/home/liutao/linux_imgs/image-20200103092425650.png)

## 1.2 打开文件

#### open介绍

open的函数原型：

```c++
int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
```

* pathname: 要打开的文件路径
* flags：用于指示打开文件的选项。常用的有O_RDONLY、O_WRONLY和O_RDWR。这三个选项必须有且只能有一个被指定。
* mode：只在创建文件时需要，用于指定所创建文件的权限位（还要受到umask环境变量的影响）。

当我们调用open函数时，实际上调用的是glibc封装的函数，然后由glibc通过自陷指令，进行真正的系统调用。也就是说，所有的系统调用都要先经过glibc才会进入操作系统。这样的话，实际上是glibc提供了一个变参函数open来满足两个函数原型，然后通过glibc的变参函数open实现真正的系统调用来调用原型二。

#### open源码

我们经常这样描述“打开一个文件”，那么这个所谓的“打开”，究竟“打开”了什么？内核在这个过程中，又做了哪些事情呢？这一切将通过分析内核源码来得到答案。跟踪内核open源码**open->do_sys_open**，代码如下：

![image-20200103093358909](/home/liutao/linux_imgs/image-20200103093358909.png)

![image-20200103093431542](/home/liutao/linux_imgs/image-20200103093431542.png)

从do_sys_open可以看出，打开文件时，内核主要消耗了两种资源：**文件描述符与内核管理文件结构file。**

#### 如何选择文件描述符

根据POSIX标准，当获取一个新的文件描述符时，要返回最低的未使用的文件描述符。Linux是如何实现这一标准的呢？在Linux中，通过do_sys_open->get_unused_fd_flags->alloc_fd（0，（flags））来选择文件描述符，代码如下：

![image-20200103095712283](/home/liutao/linux_imgs/image-20200103095712283.png)

![image-20200103095752797](/home/liutao/linux_imgs/image-20200103095752797.png)

#### 文件描述符fd与文件管理结构file

前文已经说过，内核使用fd_install将文件管理结构file与fd组合起来，具体操作请看如下代码：

![image-20200103095854963](/home/liutao/linux_imgs/image-20200103095854963.png)

当用户使用fd与内核交互时，内核可以用fd从fdt->fd[fd]中得到内部管理文件的结构struct file。

## 1.3 Creat简介

creat函数用于创建一个新文件，其等价于open（pathname，O_WRONLY|O_CREAT|O_TRUNC，mode）。APUE介绍了引入creat的原因：由于历史原因，早期的Unix版本中，open的第二个参数只能是0、1或者2。这样就没有办法打开一个不存在的文件。因此，一个独立系统调用creat被引入，用于创建新文件。现在的open函数，通过使用O_CREAT和O_TRUNC选项，可以实现creat的功能，因此creat已经不是必要的了。

creat无非是open的一种封装实现。

![image-20200103100027091](/home/liutao/linux_imgs/image-20200103100027091.png)

## 1.4 Close

close用于关闭文件描述符。而文件描述符可以是普通文件，也可以是设备，还可以是socket。在关闭时，VFS会根据不同的文件类型，执行不同的操作。

#### close源码追踪

![image-20200103100213916](/home/liutao/linux_imgs/image-20200103100213916.png)

![image-20200103100252874](/home/liutao/linux_imgs/image-20200103100252874.png)

![image-20200103100316036](/home/liutao/linux_imgs/image-20200103100316036.png)

完整的Linux文件描述符选择策略：

* Linux选择文件描述符是按从小到大的顺序进行寻找的，文件表中next_fd用于记录下一次开始寻找的起点。当有空闲的描述符时，即可分配。
* 当某个文件描述符关闭时，如果其小于next_fd，则next_fd就重置为这个描述符，这样下一次分配就会立刻重用这个文件描述符。

从____put_unused_fd退出后，close会接着调用filp_close，其调用路径为filp_close->fput。在fput中，会对当前文件struct file的引用计数减一并检查其值是否为0。当引用计数为0时，表示该struct file没有被其他人使用，则可以调用__fput执行真正的文件释放操作，然后调用要关闭文件所属文件系统的release函数，从而实现针对不同的文件类型来执行不同的关闭操作

#### 自定义files_operations

这里也选择socket文件系统作为示例，来说明Linux如何挂载文件系统指定的文件操作函数files_operations。socket.c中定义了其文件操作函数file_operations，代码如下：

![image-20200103100652208](/home/liutao/linux_imgs/image-20200103100652208.png)

函数sock_alloc_file用于申请socket文件描述符及文件管理结构file结构。它调用alloc_file来申请管理结构file，并将socket_file_ops作为参数，

![image-20200103100727591](/home/liutao/linux_imgs/image-20200103100727591.png)

在初始化file结构的时候，socket文件系统将其自定义的文件操作赋给了file->f_op，从而实现了在VFS中可以调用socket文件系统自定义的操作。

#### 遗忘close造成的问题

* 文件描述符始终没有被释放。如果文件描述符没有被释放，那么再次申请新的描述符时，就不得不扩展当前的文件表了.从上面的代码可以看出，在扩展文件表的时候，会检查打开文件的个数是否超出系统的限制。如果文件描述符始终不释放，其个数迟早会到达上限，并返回EMFILE错误（表示Too many open files（POSIX.1））
* 用于文件管理的某些内存结构没有被释放。

#### 如何查找文件资源泄漏

```shell
lsof -p PID # 从/proc/PID/fd中也可以得到类似的结果
```

## 1.5 文件偏移

文件偏移是基于某个打开文件来说的，一般情况下，读写操作都会从当前的偏移位置开始读写（所以read和write都没有显式地传入偏移量），并且在读写结束后更新偏移量