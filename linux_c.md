## 0.1 一个Linux程序的诞生

```c++
// hello_world.c
#include <stdio.h>

int main() {
    printf("Hello World.");
    return 0;
}
```

通过GCC编译，就得到了一个应用程序。

当然，整个过程看似简单，其实是GCC工具集帮我们完成了许多步骤。具体的步骤包括：

* 预处理

  * 头文件包含：该头文件的所有代码会在#include处展开

  * 宏替换：展开宏定义(注：模板是在编译期生成代码)

  * 去掉注释：

  * 条件编译：不符合的会被删除，进不到编译阶段

    ```shell
    # 查看 预处理的结果
    gcc -E hello_world.c -o hello_world.i
    # 常见错误
    1. 为什么在头文件中不能定义变量？
    这是因为定义全局变量的代码会存在于所有以\#include包含该头文件的文件中，也就是说所有的这些文件，都会定义一个同样的全局变量，这样就不可避免地造成了冲突。
    ```

    

* 编译

  * 检查语法(语法分析)

  * 生成汇编

    ```shell
    # 查看编译结果
    gcc -S hello_world.i -o hello_world.s
    ```

    

* 汇编

  * 将源代码翻译成可执行的指令，并生成目标文件

    ```shell
    # 查看汇编结果
    gcc -C hello_world.s -o hello_world.o
    ```

    

* 链接

  * 将各个目标文件-包括库文件链接成一个可执行程序。在这个过程中涉及**地址和空间的分配**、**符号解析**、**重定位**等。
  * 工具：GNU的链接器ld

* ...

我们可以使用以下命令，查看完整的编译过程

```shell
gcc -g -Wall -v hello_world.c -o hello_world
```



## 0.2 程序的构成 

在Linux下，可执行程序的格式为ELF格式，我们可以使用`readelf`查看程序的ELF格式。

```shell
readelf hello_world
```

ELF文件的主要内容是由各个section和symbol表组成。

常见的段(section)包括：

* text段：代码段，用于保存可执行指令
* data段：数据段，用于保存有非0初始值的全局变量和静态变量
* bss段：用于保存没有初始值或初值为0的全局变量和静态变量，当程序加载时，bss段中的变量会被初始化为0。这个段并不占用物理空间
* debug段：用于保存调试信息，不使用-g选项，则不会生成
* dynamic段：用于保存动态链接信息
* rodata段：用于保存只读数据，如const修饰的常量、字符串变量等
* symbol段：用于保存符号表，使用strip可以去掉符号信息
* init段：用于保存进程启动时的执行程序。当进程启动时，系统会自动执行这部分代码。
* fini段：用于保存进程退出时的执行程序。当进程结束时，系统会自动执行这部分代码。

## 0.3 程序是如何跑起来的

在Linux系统下，我们可以使用`strace`跟踪系统调用，从而帮助自己研究和理解系统程序的加载、运行和退出的过程。

```shell
strace ./hello_world
```

在Linux环境下，该命令的过程：

* 由shell调用`fork`，在子进程中执行命令
* 调用`execve`加载hello_world，然后ld会分别检查ld.so.nohwcap和ld.so.preload。其中，如果ld.so.nohwcap存在，则ld会加载其中未优化版本的库。如果ld.so.preload存在，则ld会加载其中的库——在一些项目中，我们需要拦截或替换系统调用或C库，此时就会利用这个机制，使用LD_PRELOAD来实现。
* 利用mmap将ld.so.cache映射到内存中，ld.so.cache中保存了库的路径，这样就完成了所有的准备工作。
* 接着ld加载c库——libc.so.6，利用mmap及mprotect设置程序的各个内存区域，到这里，程序运行的环境已经完成。
* write会向文件描述符1（即标准输出）输出"Hello world！\n"，返回值为13，它表示write成功的字符个数。
* 最后调用exit_group退出程序，此时参数为0，表示程序退出的状态——此例中hello-world程序返回0

## 0.4 系统调用

系统调用是操作系统提供的服务，是应用程序和内核通信的接口。相对于普通函数，系统调用的消耗是巨大的。用户空间的程序默认是通过栈来传递参数的。对于系统调用来说，**内核态和用户态使用的是不同的栈**，这使得**系统调用的参数只能通过寄存器的方式进行传递**。

## 0.5 线程安全

线程安全即程序在多线程环境下能够“安全”的执行，也即符合正确的逻辑结果。

为了实现线程安全，要么只能使用局部变量或资源，要么利用锁等同步机制，实现全局变量或资源的串行访问。

## 0.6 原子性

以前原子被认为是物理组成的最小单元，所以在计算机领域，就借其不可分割的这层含义作为隐喻。对于计算机科学来说，如果变量是原子的，那么对这个变量的任何访问和更改都是原子的。如果操作是原子的，那么这个操作将是不可分割的，要么成功，要么失败，不会有任何的中间状态。

## 0.7 可重入函数

从字面上理解，可重入就是可重复进入。在编程领域，它不仅仅意味着可以重复进入，还要求在进入后能成功执行。这里的重复进入，是指当前进程已经处于该函数中，这时程序会允许当前进程的某个执行流程再次进入该函数，而不会引发问题。这里的执行流程不仅仅包括多线程，还包括信号处理、longjump等执行流程。所以，可重入函数一定是线程安全的，而线程安全函数则不一定是可重入函数。从以上定义来看，很难说出哪些函数是可重入函数，但是可以很明显看出哪些函数是不可以重入的函数。当函数使用锁的时候，尤其是互斥锁的时候，该函数是不可重入的，否则会造成死锁。若函数使用了静态变量，并且其工作依赖于这个静态变量时，该函数也是不可重入的，否则会造成该函数工作不正常。

## 0.8 阻塞和同步

这里的阻塞与非阻塞，都是指I/O操作。在Linux环境下，所有的I/O系统调用默认都是阻塞的。那么何谓阻塞呢？阻塞的系统调用是指，当进行系统调用时，除非出错（被信号打断也视为出错），进程将会一直陷入内核态直到调用完成。非阻塞的系统调用是指无论I/O操作成功与否，调用都会立刻返回。

这里的同步与非同步，也是指I/O操作。当把阻塞、非阻塞、同步和非同步放在一起时，不免会让人眼花缭乱。同步是否就是阻塞，非同步是否就是非阻塞呢？实际上在I/O操作中，它们是不同的概念。同步既可以是阻塞的，也可以是非阻塞的，而常用的Linux的I/O调用实际上都是同步的。这里的同步和非同步，是指I/O数据的复制工作是否同步执行。以系统调用read为例。阻塞的read会一直陷入内核态直到read返回；而非阻塞的read在数据未准备好的情况下，会直接返回错误，而当有数据时，非阻塞的read同样会一直陷入内核态，直到read完成。这个read就是同步的操作，即I/O的完成是在当前执行流程下同步完成的。如果是非同步即异步，则I/O操作不是随系统调用同步完成的。调用返回后，I/O操作并没有完成，而是由操作系统或者某个线程负责真正的I/O操作，等完成后通知原来的线程。