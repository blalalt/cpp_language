## 7.1 引言

对象位于内存的某个地址中，如果知道对象的地址和类型，就能访问它。在C++中存放和使用内存地址是通过指针和引用完成的。

## 7.2 指针

对于类型 T 来说， T* 表示 指向 T 的指针，也即 T* 类型的变量能够存放 T 类型对象的地址。

对指针的一个基本操作时解引用(dereferencing)，即引用指针所指的对象，也被称为间接取值(indirection) 。

```c++
char c = 'a';
char* p = &c; // p 存放 c的地址
char c2 = *p; // * 为解引用符
```

### 7.2.1 void*

void* 的含义是 指向未知类型对象的指针。

除了 **函数指针和指向类成员的指针**，指向其他任意类型对象的指针都能被赋给一个void*类型的变量。

要想使用void*，必须先把它显示转换成某一特定类型的指针。

void* 最主要的用途是 当我们无法假定对象的类型时，向函数传递指向该对象的指针；还用于从函数返回未知类型的对象。要想使用这些对象，必须先进行显示类型转换(推荐使用 static_cast(type*))

### 7.2.2 nullptr

字面值常量nullptr 表示空指针，即不指向任何对象的指针，可以把nullptr赋给其他任意指针类型，但不能赋给其他内置类型。

```c++
int* pi = nullptr; // ok
int i = nullptr; // 错误 
```

相比NULL的好处：

* 可读性更强
* 当一组重载函数既可以接受指针也可接受整数时，使用nullptr而非NULL能够避免语义混淆。因为NULL==0；

## 7.3 数组

T[size] 包含size个T类型元素的数组，索引值范围是 0 到 size-1.

数组不能进行赋值操作，一旦需要，数组名会隐式地转换成执行数组首元素的指针。特别要注意避免在接口中使用数组(比如作为函数的参数)，因为数组名的隐式转换指针是很多错误的根源。使用指针作为函数参数。

通常 char* 和 const char* 指向以0结尾的字符序列。

### 7.3.1 数组的初始化器

使用值的列表初始化数组

```c++
int v1[] = {1,2,3,4};
```

注意，c++没有为数组提供内置的拷贝操作，不允许用一个数组初始化另一个数组，同样，不允许以传值的方式传递数组。

## 7.5 指针与const

C++提供了两种与常量有关的概念：

* constexpr：指示或确保在编译时求值；
* const：在当前作用域内，值不发生改变。主要用来规定接口的不可修改性。

很多对象的值一旦初始化就不会再改动：

* 符号化常量比字面值常量更易维护
* 经常通过指针读取数据，很少通过指针写入数据
* 绝大多数函数的参数只负责读取数据，很少写入数据

为了表达一经初始化就不可修改的特性，可以在对象的定义中加const关键字

```c++
const int a = 90;
const int v[] = {1, 2, 3};
const int x; // 错误，缺少初始化器
```

因为无法对 const 对象赋值，所以必须在定义的时候进行初始化。

一个指针牵扯两个对象： 指针本身 和 指针所指的对象，因此

```c++
// 在指针声明中前置const关键字，所指的对象而非指针成为常量
const char* pc = 'Gam'; // 指向常量的指针，即不能通过该指针修改所指的对象

// 后置const，指针本身成为常量
char* const pc1 = 'Gam'; // 指向char的常量指针，也即 不允许指针再指向其它的对象

```

**注意，常量的地址不能赋给某个不受限的指针，虽然可以通过显式类型转换的方式移除对于指针指向常量的限制。**

## 7.7 引用

通过使用指针，我们就能以很低的代价在一个范围内传递大量的数据，与直接拷贝所有数据不同，只需传递指向这些数据的指针的值就可。

使用指针与使用对象名存在如下差别：

* 语法形式不同，*p,p->m分别取代了obj,obj.m
* 同一指针在不同时刻可以指向不同对象
* 指针的值可能是nullprt，也可能指向一个我们并不想要的对象。

因此，必须花费大量的精力去管理变化多端的指针变量，还要防范指针取值为nullptr的情况。

解决这些问题的语言机制就是使用引用(reference)。和指针类似，引用作为对象的别名存放的也是对象的机器地址。与指针相比，引用不会带来额外的开销。

引用与指针的区别：

* 访问引用与访问对象本身 从语法形式上看是一样的

* 引用所引的永远是一开始初始化的那个对象

* 不存在空引用

  指针和引用是两种无须拷贝就能在别处使用对象的机制，如果需要更换所指的对象应该使用指针。如果想让某个名字用永远对应同一个对象，应该使用引用。如果要表示 值空缺 应该使用指针，因为没有空引用这一概念。

引用的实现方式类似于常量指针，每次使用引用实际上是对该指针进行解引用操作，不过，引用不是对象，而指针是一种对象，因为我们既不能令某个指针指向引用，也不能定义引用的数组。

C++为了支持对象的不同用法，设计了三种不同形式的引用：

* 左值引用(lvalue reference)：引用那些我们希望改变值的对象，对象可以由用户写入内容。

* const 引用(const reference)：不希望改变值的对象，从用户的角度来看是不可修改的。

* 右值引用(rvalue reference)：所引用对象的值在我们使用之后就无须保留了(比如临时变量)，用户可以修改这个对象，并且认定这个对象以后不会被用到了。

  右值引用可以绑定到右值，但不能绑定到左值。

  ```c++
  int x = 10;
  int&& rx = static_cast<int&&> x;
  // 等价于
  int&& rx = move(x);
  ```

  move(x) 实际上并不是移动x而只是为x创建一个右值引用。

const左值引用和右值引用都能绑定右值，但是它们的目标完全不同：

* 右值引用实现了一种 ‘破坏性读取’
* const 左值引用的作用是保护参数内容不被修改

尽量使用const引用作为函数的参数，因为它可以接受的参数类型更多。

**引用的引用**

让引用指向某类型的引用，得到的还是该类型的引用，永远是左值引用优先。