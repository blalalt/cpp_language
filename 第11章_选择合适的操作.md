## 11.1 其他运算符

### 11.1.1 逻辑运算符

&&(与)、||(或)、!(非)接受算术类型以及指针类型的运算对象，将其转换为bool类型，最后返回一个bool类型的结果。只有当逻辑上需要是 && 和 || 才会对其第二个实参求值。因此，这两个运算符都具有控制求值顺序的功能

```c++
while (p && !whitespace(*p)) ++p;
```

如果 p 是nullptr，则不会对其执行解引用操作。也即发生截断。

### 11.1.2 位逻辑运算符

位逻辑运算符 & | ~ ^ >> << 作用于整数对象，即，char, short , int. long, long long 及其对应的 unsigned 版本，以及 bool. wchar_t, char16_t, char32_t等类型，一个普通的enum(非 enum class)可被隐式地转换成整数类型，从而作为位逻辑运算符的运算对象。

位逻辑运算符常用于实现一个小集合的概念(位向量)。此时，无符号整数的每一位表示集合的一个成员，位的数量限制了成员的数量。二元运算符 & 表示求交操作，| 表示求并操作，^表示异或操作， ~表示求补操作。我们可以使用枚举类型命名该集合的成员。

```c++
enum ios_base::iostate {
	goodbit=0,eofbit=1,faibit=2,badbit=4;
}
state = goodbit;
if (state & (badbit | failbit)) // 流的状态不好
...
state |= eofbit; // 输入的末尾
int old = cin.rdstate();
if (cin.rdstate() ^ old) {} // 状态有变化吗
```

### 11.1.3 条件表达式

```c++
value = cond ? expr1: expr2
```

expr1, expr2 表达式的类型必须相同，或者都能隐式地转换成同一种类型。此外 throw 表达式也能作为条件表达式的一个分支。

### 11.1.4 递增与递减

++ 和 -- 既可以作为前缀运算符，又可以作为后缀运算符。++x的值是x的新值，x++是x的旧值。

## 11.2 自由存储

命名对象的生命周期由其作用域决定。在某些情况下，我们希望对象与创建它的语句所在的作用域独立开来。运算符new负责分配这样的对象，运算符delete负责销毁它们。

**new分配的对象位于自由存储之上(或者说在堆上或在动态内存中)**。

对于一个用new创建的对象，我们必须使用delete显示的将它销毁，否则它将一直存在。delete运算符只能作用于new返回的指针或者nullptr。

如果被删除的对象的类型是一个含有析构函数的类，则delete将调用该析构函数。

### 11.2.1 内存管理

自由存储的问题主要包括：

* 对象泄露：使用new，但是忘记delete释放掉分配的对象。
* 提前释放：在尚有其他指针指向该对象并且后续仍会使用该对象的情况下过早的delete。
* 重复释放：同一对象被释放两次，两次调用对象的析构函数。

对象泄露是一种潜在的严重错误， 因为它可能**会令程序面临资源耗尽**的情况。

提前释放更容易造成恶果， 因为**指向“ 已删对象” 的指针所指的可能已经不是一个有效的对象**了（此时读取的结果很可能与预期不符） ， **又或者该内存区域已经存放了其他对象**（ 此时对该区域执行写人操作将会影响本来无关的对象）。

```c++
int* p1 = new int{99};
int* p2 = p1;
delete p1;
*p2 = 999; // 该行代码可能会造成出错
```



重复释放的问题在于资源管理器通常无法追踪资源的所有者。

为了避免以上问题，建议使用这两种方法代替裸new和delete：

* 除非万不得已不要把对象放在自由存储上，优先使用作用域内变量。
* 当在自由存储上构建对象时，把它的指针放在一个管理器对象(句柄)。此类对象通常含有一个析构函数，可以确保释放资源。

其中，第二个规则检查RALL(资源获取即初始化)，RALL是一项避免资源泄露的基本技术，让我们可以安全便捷地使用异常机制处理错误。

把分配和释放资源的操作都限定在其内部进行。例如标准库中的 vector 和 用于管理的 智能指针。

### 11.2.2 数组

普通 delete 用于删除单个对象，delete[] 负责删除数组。

### 11.2.4 重载 new

#### 11.2.4.1 nothrow new

## 11.3 列表

