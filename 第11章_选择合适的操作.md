## 11.1 其他运算符

### 11.1.1 逻辑运算符

&&(与)、||(或)、!(非)接受算术类型以及指针类型的运算对象，将其转换为bool类型，最后返回一个bool类型的结果。**只有当逻辑上需要是 && 和 || 才会对其第二个实参求值**。因此，这两个运算符都具有控制求值顺序的功能

```c++
while (p && !whitespace(*p)) ++p;
```

如果 p 是nullptr，则不会对其执行解引用操作。也即发生截断。

### 11.1.2 位逻辑运算符

位逻辑运算符 & | ~ ^ >> << 作用于整数对象，即，char, short , int. long, long long 及其对应的 unsigned 版本，以及 bool. wchar_t, char16_t, char32_t等类型，一个普通的enum(非 enum class)可被隐式地转换成整数类型，从而作为位逻辑运算符的运算对象。

位逻辑运算符常用于实现一个小集合的概念(位向量)。此时，无符号整数的每一位表示集合的一个成员，位的数量限制了成员的数量。二元运算符 **& 表示求交操作**，**| 表示求并操作**，**^表示异或操作**， **~表示求补操作**。我们可以使用枚举类型命名该集合的成员。

```c++
enum ios_base::iostate {
	goodbit=0,eofbit=1,faibit=2,badbit=4;
}
state = goodbit;
if (state & (badbit | failbit)) // 流的状态不好
...
state |= eofbit; // 输入的末尾
int old = cin.rdstate();
if (cin.rdstate() ^ old) {} // 状态有变化吗
```

### 11.1.3 条件表达式

```c++
value = cond ? expr1: expr2
```

expr1, expr2 **表达式的类型必须相同，或者都能隐式地转换成同一种类型**。此外 throw 表达式也能作为条件表达式的一个分支。

### 11.1.4 递增与递减

++ 和 -- 既可以作为前缀运算符，又可以作为后缀运算符。++x的值是x的新值，x++是x的旧值。

## 11.2 自由存储

命名对象的生命周期由其作用域决定。在某些情况下，我们希望对象与创建它的语句所在的作用域独立开来。运算符new负责分配这样的对象，运算符delete负责销毁它们。

**new分配的对象位于自由存储之上(或者说在堆上或在动态内存中)**。

对于一个用new创建的对象，我们必须使用delete显示的将它销毁，否则它将一直存在。delete运算符只能作用于new返回的指针或者nullptr。

如果被删除的对象的类型是一个含有析构函数的类，则delete将调用该析构函数。

### 11.2.1 内存管理

自由存储的问题主要包括：

* 对象泄露：使用new，但是忘记delete释放掉分配的对象。
* 提前释放：在尚有其他指针指向该对象并且后续仍会使用该对象的情况下过早的delete。
* 重复释放：同一对象被释放两次，两次调用对象的析构函数。

对象泄露是一种潜在的严重错误， 因为它可能**会令程序面临资源耗尽**的情况。

提前释放更容易造成恶果， 因为**指向“ 已删对象” 的指针所指的可能已经不是一个有效的对象**了（此时读取的结果很可能与预期不符） ， **又或者该内存区域已经存放了其他对象**（ 此时对该区域执行写人操作将会影响本来无关的对象）。

```c++
int* p1 = new int{99};
int* p2 = p1;
delete p1;
*p2 = 999; // 该行代码可能会造成出错
```



重复释放的问题在于资源管理器通常无法追踪资源的所有者。

为了避免以上问题，建议使用这两种方法代替裸new和delete：

* 除非万不得已不要把对象放在自由存储上，优先使用作用域内变量。
* 当在自由存储上构建对象时，把它的指针放在一个管理器对象(句柄)。此类对象通常含有一个析构函数，可以确保释放资源。

其中，第二个规则检查RALL(资源获取即初始化)，**RALL是一项避免资源泄露的基本技术，让我们可以安全便捷地使用异常机制处理错误。**

**把分配和释放资源的操作都限定在其内部进行。例如标准库中的 vector 和 用于管理的 智能指针。**

### 11.2.2 数组

普通 delete 用于删除单个对象，delete[] 负责删除数组。

### 11.2.4 重载 new

#### 11.2.4.1 nothrow new

## 11.3 列表

我们能用{} 列表初始化命名变量，此外，{} 列表还能作为表达式出现。它们的表现形式有两种：

* 限定为某种类型，形如 T{...}，意思是 "创建一个T类型的对象并用 T{...} 初始化它"。
* 未限定的 {...}，其类型根据上下文确定。

```c++
struct S {int a, b;}
struct SS {double a, b;}

void f(S);
void g(S);
void g(SS);

void h() {
    f({1, 2}); // OK, 调用 f(S{1, 2})
    
    g({1, 2}); // 错误，存在二义性
    g(S{1, 2}); // OK, 调用g(S)
    g(SS{1, 2}); // OK, 调用g(SS)
}
```

当我们用列表初始化命名变量时，列表中可以包含0个、1个或多个元素。{} 列表构建的是某种类型的对象，因此其中包含的元素数量和类型都必须符合构建该类型对象的要求。

### 11.3.1 实现模型

{} 列表的实现模型由三部分组成：

* 若{} 被用作**构造函数的实参**，其实现过程与使用() 类似。
* 若{} 被用作**初始化一个聚合体**(一个数组或一个未提供构造函数的类)的元素，则列表的每个元素分别初始化聚合体中的一个元素。
* 若{} 被用作**构建一个 initializer_list 对象**，则列表的每个元素分别初始化 initializer_list 的底层数组的一个元素。

initializer_list  **本身是个小对象**(可能只占两个字空间)，因此以传值方式传递它完全可行。

{} 列表是**不可修改的**，意味着接受列表元素的容器必须使用拷贝操作，而不能使用移动操作。

### 11.3.2 限定列表

把初始化器列表用作表达式的基本思想是：如果能用下面的语句初始化一个变量x

```c++
T x{v};
```

那么也可以用 T{v}**(在局部作用域中创建一个临时对象)**或者 new T{v}**(把目标对象置于自由存储之上，并返回一个指向该对象的指针)** 的形式创建一个对象并将其当成一条表达式。

```c++
struct S{ int a, b;};
void f() {
    S v{7, 8}; // 直接初始化一个变量
    v = S{7, 8}; //用限定列表进行赋值
    S* p = new S{7, 8}; // 把目标对象置于自由存储之上
}
```

### 11.3.3 未限定列表

当我们明确知道所用类型时，可以使用未限定列表。它只能被用作一条表达式，并且仅限于以下场景：

* 函数实参
* 返回值
* **赋值运算符的右侧对象**
* 下标

```c++
int f(double d, Matrix& m) {
    int v{7}; // 初始化器 直接初始化
    int v2 = {7}; // 初始化器 拷贝初始化
    int v3 = m[{2,3}]; // 假设 m 接受一个值对 作为下标
    
    v = {8}; // 赋值运算符的右侧运算对象
    v += {8}; // 赋值运算符的右侧运算对象
    
    {v} = 9; // 错误，不能 作为非赋值运算符的运算对象
    v = 7 + {10}; // 错误，不能 作为非赋值运算符的运算对象
    
    f({10}); // 函数实参
    return {11}; // 返回值
}
```

## 11.4 lambda 表达式

lambda 表达式 有时也被称为 lambda 函数。它是**定义和使用匿名函数对象**的一种简便方式。**传统方式是先定义一个含有 operator()的命名类，随后再创建该类的一个对象并通过该对象调用函数**。与之相比，lambda简单，尤其是当我们想**把操作当成实参传给算法时(被称为回调)**。

一个lambda表达式包含以下组成要件：

* 一个可能为空的捕获列表，定义环境中**那些名字能被用**在表达式内，以及这些名字的**访问方式**时拷贝还是引用。捕获列表位于[] (称为引入符)内。
  * []: 空捕获列表，意味着**表达式内部无法使用其外层上下文中的任何局部名字**。其数据需要**从实参或者非局部变量(名字空间变量包括全局变量)**中获得。
  * \[&]: 引用隐式捕获，所有**局部变量都通过引用访问**。
  * \[=]: 通过值隐式捕获，所有名字都**指向局部变量的副本**，在lambda表达式调用点获得的。
  * \[捕获列表]: 显式捕获，捕获列表通过值或引用的方式捕获的局部变量的名字列表。以&为前缀的变量名字通过引用捕获，其他通过值捕获。**捕获列表中可以出现this**。
  * \[&，捕获列表]：对于名字没有出现在捕获列表中的局部变量。通过引用隐式捕获。列出的名字不能以&为前缀。**捕获列表中可以出现this**。
  * [=，捕获列表]：对于名字没有出现在捕获列表中的局部变量。通过值隐式捕获。列出的名字必须以&为前缀。**捕获列表中不允许包含this**。捕获列表中的变量名通过引用的方式捕获。
* 一个可选的参数列表，指明表达式所需的参数。参数列表位于() 内。
  * 参数列表可以忽略。
  * 传递参数的规则与向函数传递参数是一样的。
* 一个可选的mutable 修饰符，指明表达式 可能会修改它自身的状态(即，**改变通过值捕获的变量的副本**，注意不是修改通过引用捕获的变量的状态)。
* 一个可选的 noexcept 修饰符。
* 一个可选的 -> 形式的返回类型。
  * **lambda 表达式的返回类型能由lambda表达式本身推断的到。函数无法做到**
* 一个表达式体 (body)，指明要执行的代码。

**lambda与函数的区别在于函数没有 提供局部变量的 捕获功能**，这意味着lambda 可以作为局部函数使用，而普通函数不能。

### 11.4.1 lambda的类型

lambda 可以认为是函数对象的类型，这个类型被称为**闭包类型(closure type)**，它对于lambda表达式来说是唯一的。因此，**任意两个lambda的类型都不同**。

lambda 是一种局部类类型，含有一个构造函数以及一个const成员函数 operator ()()。

除了作为参数外，lambda还可用于初始化一个声明为auto 或者 std::function<R(AL)>的变量。其中，R是lambda的返回类型，AL是她的类型参数列表。

例如，试图编写一个能更改C风格字符串中字符的lambda

```c++
auto rev = [&rev](char* a, char* e) {if (1<3-a) {swap(*a, *--e); rev(++b, e);}  }; //错误
```

我们无法在推断出一个auto变量的类型之前使用它。

相反，我们应该先引入一个名字，再使用它：

```c++
void f(string& s1, string& s2) {
    function<void(char* a, char* e)> rev = [&rev](char* a, char* e) {if (1<3-a) {swap(*a, *--e); 
    rev(&s1[0], &s1[0]+s1.size());
    rev(&s2[0], &s2[0]+s2.size());
}
```

这样，就可以确保在使用rev之前就知道它的类型了。

如果只是想给lambda起个名字，而不会递归的使用它，则可以考虑使用auto：

```c++
void f(string& s1, string& s2) {
    auto rev = [&rev](char* a, char* e) {while (1<e-a) swap(*a++, *--e)}; 
    rev(&s1[0], &s1[0]+s1.size());
    rev(&s2[0], &s2[0]+s2.size());
}
```

如果lambda什么也不捕获，则我们可以将它赋值给一个正确类型的函数指针。

```c++
double (*p1)(double) = [](double a) {return a;};
double (*p1)(double) = [](double a) {return a;}; //错误，捕获了内容
double (*p1)(double) = [](double a) {return a;}; //错误，参数类型不匹配
```

## 11.5 显示类型转换

有时候我们必须把一种类型的值转换成另一种类型的值。很多类型转换都是根据语言规则隐式执行的。

C++提供了多种显示类型转换的操作：

* 构造，使用{}符合提供对新值类型安全的构造。
* 命名的转换:
  * const_cast：参与转换的类型仅在const修饰符及volatile修饰符上有所区别。对声明为const的对象获得写入的权利。
  * static_cast：执行关联类型之间的转换。比如，一种指针类型想统一类层次中其他指针类型的转换，或整数向枚举，浮点向整数等。反转一个定义良好的隐式类型转换。
  * reinterpret_cast：处理非关联类型之间的转换。比如，整数向指针，指针向另一个非关联指针类型的转换。改变位模式的含义。
  * dynamic_cast：执行指针或引用 向类层次体系的类型转换，并执行运行时检查。
  * C风格，不推荐。